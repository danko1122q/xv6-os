package main

import (
	"fmt"
)

// main generates x86 interrupt vector table assembly code.
// It creates 256 interrupt handlers and a vector table pointing to them.
// This output is typically redirected to a .S file for assembly.
func main() {
	fmt.Println("# generated by vectors.go - do not edit")
	fmt.Println("# handlers")
	fmt.Println(".globl alltraps")

	// Generate 256 interrupt vector handlers (0-255)
	for i := 0; i < 256; i++ {
		fmt.Printf(".globl vector%d\n", i)
		fmt.Printf("vector%d:\n", i)
		
		// x86 hardware automatically pushes an error code for certain interrupts.
		// For interrupts that don't push an error code, we push a dummy 0 to
		// maintain a consistent stack frame layout.
		// Interrupts with hardware error codes: 8, 10-14, 17
		if !(i == 8 || (i >= 10 && i <= 14) || i == 17) {
			fmt.Println("  pushl $0")
		}
		
		// Push the interrupt number onto the stack
		fmt.Printf("  pushl $%d\n", i)
		
		// Jump to the common trap handler
		fmt.Println("  jmp alltraps")
	}

	// Generate the vector table data section
	fmt.Println("\n# vector table")
	fmt.Println(".data")
	fmt.Println(".globl vectors")
	fmt.Println("vectors:")
	
	// Create an array of pointers to each interrupt handler
	for i := 0; i < 256; i++ {
		fmt.Printf("  .long vector%d\n", i)
	}
}